# 数据结构：表

**关于作者**

>郭孝星，非著名程序员，主要从事Android平台基础架构与中间件方面的工作，欢迎交流技术方面的问题，可以去我的[Github](https://github.com/guoxiaoxing)提交Issue或者发邮件至guoxiaoxingse@163.com与我联系。

**文章目录**

- ArrayList实现原理
- LinkedList实现原理

从这篇文章开始我们来分析常用的数据结构，例如：表、栈、队列、图、树等。

>我们将形如A1，A2，A3，A4 ... AN称之为一个表，大小为0的表我们称之为空表。

数组是最为简单的一种表，它在查找操作是线性时间的，但是插入与删除则潜藏额外的开销。

- 如果插入的位置在第一个，则需要将后面的元素全部向后移动一位，时间复杂副为O(N)
- 如果插入的位置在最后一个，则无需移动其他元素，时间复杂副为O(1)

总结起来，插入/删除的时间时间复杂度为O(N)。

为了避免插入/删除带来的额外开销，我们又引入了链表，其中，链表又可以分为单链表与双链表。

>链表由一系列节点组成，这些节点不必在内存中相连，每个节点均含有表元素和到包含该元素后继元的节点的链，称为next链。这样的链表
称为单链表，另外，如果节点还包含指向它在链表中的前驱节点的链，则成该链表为双链表。

说完了关于表的基本概念，我们来聊一聊Java中对表的基本实现。Java中用接口List来定义表的基本功能，包括增、删、改、查等基本操作。

List接口定义如下：

```java
public interface List<E> extends Collection<E> {
    // Query Operations
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);

    // Modification Operations
    boolean add(E e);
    boolean remove(Object o);

    // Bulk Modification Operations
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean addAll(int index, Collection<? extends E> c);
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    void clear();


    // Comparison and hashing
    boolean equals(Object o);
    int hashCode();


    // Positional Access Operations
    E get(int index);
    E set(int index, E element);
    void add(int index, E element);
    E remove(int index);


    // Search Operations
    int indexOf(Object o);
    int lastIndexOf(Object o);


    // List Iterators
    ListIterator<E> listIterator();
    ListIterator<E> listIterator(int index);

    // View
    List<E> subList(int fromIndex, int toIndex);
    
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.ORDERED);
    }
    
    default void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final ListIterator<E> li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
    default void sort(Comparator<? super E> c) {
        Collections.sort(this, c);
    }
}

```
关于List接口，我们有两个常用的实现类。

- ArrayList：提供了一种List ADT的可增长的实现，优点在于get、set花费常量时间，缺点在于插入、删除代价昂贵。
- LinkedList：提供了一种List ADT的双链表的实现。优点在于插入、删除操作开销较小，缺点在于不用于做索引，get操作代价昂贵。

## ArrayList实现原理

> ArrayList提供了一种List ADT的可增长的实现，优点在于get、set花费常量时间，缺点在于插入、删除代价昂贵。

ArrayList是以数组为基础实现的线性数据结构，具体说来，它有以下特点：

- 快速查找，在物理内存上采用顺序存储结构，可以根据索引进行快速查找。
- 容量动态增长：当数组容量不够用时，创建一个比原来更大的数组，将原来数组的元素复制到新数组中。
- 可以插入null
- 没有做同步

ArrayList类图如下所示：

实现了以下接口：

- List：List ADT相关方法。
- RandomAccess：随机访问功能，在ArrayList中通过索引快速获取元素，这就是随机访问功能。
- Cloneable：返回ArrayList的浅拷贝。
- Serialiable：实现了序列化功能。

ArrayList采用数组存取元素。

```java
//保存ArrayList数据的数组，它采用transient关键字标记，说明序列化ArrayList忽略掉该字段
transient Object[] elementData;

//数据数量
private int size;
```

我们接下来看看ArrayList关于增、删、改、查的实现。

### add

时间复杂度：O(n)

实现原理：ArrayList可以在指定位置增加元素，增加元素后，当前元素后面的元素都要向后移动一位。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }

    public void add(int index, E element) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        
        //将数组elementData从index位置开始的所有元素，拷贝到elementData从index + 1位置开始的位置
        //也就是index位置后面的元素全部向后移动一位
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
}
```

ArrayList会调用ensureCapacityInternal()方法来保证数组容量的自动增长，我们先来看看它的实现。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
   private void ensureExplicitCapacity(int minCapacity) {
           modCount++;
   
           // overflow-conscious code
           if (minCapacity - elementData.length > 0)
               grow(minCapacity);
       }
       
       //ArrayList内部数组的最大容量
       private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
   
       private void grow(int minCapacity) {
           // overflow-conscious code
           int oldCapacity = elementData.length;
           int newCapacity = oldCapacity + (oldCapacity >> 1);
           if (newCapacity - minCapacity < 0)
               newCapacity = minCapacity;
           if (newCapacity - MAX_ARRAY_SIZE > 0)
               newCapacity = hugeCapacity(minCapacity);
           // minCapacity is usually close to size, so this is a win:
           elementData = Arrays.copyOf(elementData, newCapacity);
       } 
}
```

可以看到ArrayList调用grow(int minCapacity)方法来增加容量，这里有个最小容量minCapacity，它等于当前数组大小size+1。该方法的
计算流程如下：

1. 旧的容量 = 过去数组的大小
2. 新的容量 = 过去容量 + 过去容量>>1
3. 上一步计算的新容量如果小于最小容量则使用最小容量作为新的容量
4. 如果上一步得到的容量大于最大数组容量，则使用最大数组容量作为新的容量
5. 将原有数组的数据拷贝到新数组，并赋值给elementData。

这里我们还要提到一个数组拷贝的方法，它是一个native方法。

```java
public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);
```
- Object src：源数组
- int  srcPos：原数组开始拷贝的位置
- Object dest：目标数组
- int destPos：目标数组开始拷贝的位置
- int length：被拷贝元素的数量

### remove

时间复杂度：O(n)

实现原理：删除指定位置的元素，删除元素后，把该元素后面的所有元素向前移动一位

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

    public E remove(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        modCount++;
        E oldValue = (E) elementData[index];

        int numMoved = size - index - 1;
        if (numMoved > 0)
            //当前删除index后面的元素全部向前移动一位
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }

    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
}
```
ArrayList提供了两种移除元素的方法，按索引移除与按对象移除，按对象移除会先去遍历该对象的索引，然后再按索引移除。

### set

时间复杂度：O(1)

实现原理：替换内部数组相应位置上的元素

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
    public E set(int index, E element) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        E oldValue = (E) elementData[index];
        elementData[index] = element;
        return oldValue;
    }
}
```
### get

时间复杂度：O(1)

实现原理：根据指定索引获取当前元素，无需额外的计算。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
    
   public E get(int index) {
       if (index >= size)
           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

       return (E) elementData[index];
   }
}
```

## LinkedList实现原理

>LinkedList提供了一种List ADT的双链表的实现。优点在于插入、删除操作开销较小，缺点在于不用于做索引，get操作代价昂贵。