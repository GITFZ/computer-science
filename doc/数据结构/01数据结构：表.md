# 数据结构：表

**关于作者**

>郭孝星，非著名程序员，主要从事Android平台基础架构与中间件方面的工作，欢迎交流技术方面的问题，可以去我的[Github](https://github.com/guoxiaoxing)提交Issue或者发邮件至guoxiaoxingse@163.com与我联系。

**文章目录**

- ArrayList实现原理
- LinkedList实现原理

从这篇文章开始我们来分析常用的数据结构，例如：表、栈、队列、图、树等。

>我们将形如A1，A2，A3，A4 ... AN称之为一个表，大小为0的表我们称之为空表。

数组是最为简单的一种表，它在查找操作是线性时间的，但是插入与删除则潜藏额外的开销。

- 如果插入的位置在第一个，则需要将后面的元素全部向后移动一位，时间复杂副为O(N)
- 如果插入的位置在最后一个，则无需移动其他元素，时间复杂副为O(1)

总结起来，插入/删除的时间时间复杂度为O(N)。

为了避免插入/删除带来的额外开销，我们又引入了链表，其中，链表又可以分为单链表与双链表。

>链表由一系列节点组成，这些节点不必在内存中相连，每个节点均含有表元素和到包含该元素后继元的节点的链，称为next链。这样的链表
称为单链表，另外，如果节点还包含指向它在链表中的前驱节点的链，则成该链表为双链表。

说完了关于表的基本概念，我们来聊一聊Java中对表的基本实现。Java中用接口List来定义表的基本功能，包括增、删、改、查等基本操作。

List接口定义如下：

```java
public interface List<E> extends Collection<E> {
    // Query Operations
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);

    // Modification Operations
    boolean add(E e);
    boolean remove(Object o);

    // Bulk Modification Operations
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean addAll(int index, Collection<? extends E> c);
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    void clear();


    // Comparison and hashing
    boolean equals(Object o);
    int hashCode();


    // Positional Access Operations
    E get(int index);
    E set(int index, E element);
    void add(int index, E element);
    E remove(int index);


    // Search Operations
    int indexOf(Object o);
    int lastIndexOf(Object o);


    // List Iterators
    ListIterator<E> listIterator();
    ListIterator<E> listIterator(int index);

    // View
    List<E> subList(int fromIndex, int toIndex);
    
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.ORDERED);
    }
    
    default void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final ListIterator<E> li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
    default void sort(Comparator<? super E> c) {
        Collections.sort(this, c);
    }
}

```
关于List接口，我们有两个常用的实现类。

- ArrayList：提供了一种List ADT的可增长的实现，优点在于get、set花费常量时间，缺点在于插入、删除代价昂贵。
- LinkedList：提供了一种List ADT的双链表的实现。优点在于插入、删除操作开销较小，缺点在于不用于做索引，get操作代价昂贵。

## ArrayList实现原理



## LinkedList实现原理